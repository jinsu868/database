1. 분산 락의 방식 중 Redis를 사용한 방법에서 Redisson과 Lettuce의 차이는 뭔가요?

> 문진수
>
> Redisson과 Lettuce는 모두 Redis 클라이언트 라이브러리입니다. Redisson은 Pub/Sub 기반의 락 알림 메커니즘을 사용하여 락이 해제되었을 때 대기 중인 클라이언트에게 알림을 보내줍니다. 이를 통해 불필요한 리소스 소모 없이 효율적으로 락을 관리할 수 있습니다. 반면 Lettuce는 스핀 락 방식으로 동작하여 락을 획득할 수 있을 때까지 짧은 간격으로 반복적으로 Redis에 질의합니다. 락 대기 중에 CPU 사용량이 높아질 수 있습니다.

> 백명규
> 
> - Lettuce는 Redis 관련된 명령어를 자바에서 처리할 수 있게 해주는 라이브러리임. 그런데 저수준의 명령어로 되어있기 때문에 사용이 어려움. 
> 또한, set nx 방식으로 분산락을 구현한다고 했을 때, 스핀락 방식으로 동작하기 때문에 동시에 요청이 오는 경우 block 되는 문제로 오랜 시간 동안 락을 잡는다면
> Redis 자원을 낭비할 수 있음. 대신 자유도가 높음!
> - Rettuce는 Redis 관련된 명령어를 자바에서 처리할 수 있게 해주는데 조금 고수준의 추상화를 제공함. Lock의 경우에는 rLock과 같은 Lock 라이브러리를
> 상속 받아 구현한 걸 주기 때문에 사용이 쉬움. 그리고 애플리케이션에서 분산락 용도로 사용할 때에 Lock을 잡는 부분에 있어 Pub/Sub 방식을 사용하기 때문에
> 불필요하게 기다리면서 자원을 낭비하는 게 아니라 본인이 원하는 락에 관한 토픽을 구독하고 나서 나중에 락이 풀렸을 때 락을 푼 쪽에서 보낸 응답을 받는 방식으로 동작함.
> 그래서 약간의 부하를 좀 줄일 수 있다.
---
2. RedLock 알고리즘에 관해서 설명해주세요.

> 문진수
>
> N개의 레디스 인스턴스 노드들을 이용하여 Quorum  이상의 노드에서 잠금을 획득하면 분산락 획득으로 취급하는 알고리즘을 RedLock이라고 합니다. RedLock 알고리즘은 노드들간의 동기화된 시간이 없는 상태에서 로컬 시간이 거의 동일한 속도로 갱신됨을 가정합니다. 때문에 Clock Drift 현상이 발생하면 오동작을 할 가능성이 생깁니다. 이러한 문제를 해결하기 위해 Versioning 방식을 도입할 수 있겠지만 아쉽게도 RedLock은 이 기능을 제공하지 않기 때문에 한계가 존재하는 알고리즘입니다.

> 백명규
> 
> RedLock 알고리즘은 락에 관한 고가용성을 정족수 기반의 합의 시스템을 위해서 두기 위한 시스템입니다.
> RedLock 알고리즘은 기본적으로 N(2k + 1)개의 단일 레디스 인스턴스들을 묶어 그 중 k + 1개 이상의 동의를 구했을 때 락을 획득한 것으로 간주합니다.
> 이렇게 하는 이유는 단일 레디스가 다운되었을 때 고가용성을 제공하기 위해서입니다.
> 
> ※ 리플리케이션은 왜 이 문제를 해결하지 못할까?에 대해서는 Redis 공식문서의 분산락 부분을 보면 알 수 있음!(동기화는 비동기...)

---
3. OLTP와 OLAP의 차이가 무엇인가요?

> 문진수
>
> OLPT는 Online Transaction Processing의 약자로 실시간으로 사용자의 데이터를 갱신하고 조회하는 단위의 작업을 말합니다. OLAP는 Online Analytical Processing의 약자로 대규모 데이터 집합을 분석하고 의사 결정 지원을 위한 데이터베이스 시스템의 접근 방식입니다. 주로 데이터 웨어하우스, 데이터 마이닝에 쓰입니다.

> 백명규
> 
> - OLTP : 작은 데이터 우리가 일반적으로 애플리케이션에서 일부 데이터를 가지고서 화면에 보여주고 할 때(속도가 목적)
> - OLAP : 데이터 엔지니어 같은 사람들이 전체 데이터를 분석하고 데이터 통계 등을 활용해서 의미있는 추론 등을 뽑아내는 용도(속도보단 의미있는 정보를 얻는 게 목적) 

---
4. 비관계형 데이터베이스를 써보신 경험이 있으신가요? 
RDBMS랑 비교했을 때 어떤 상황에 쓰셨는지 어떤 데이터베이스를 왜 선택하셨는지 알고 싶습니다.

> 백명규
> 
> NoSQL을 쓰는 경우는 총 세 가지로 정리를 해볼 수 있을 것 같음.
> 
> 1. 관계형 데이터베이스는 스키마에 대해서 유연하지 않은 시스템임. 그런데 로그나 아니면 변경 사항이 자주 발생할 수 있는 테이블이라면
> NoSQL 중 MongoDB 같은 걸 활용하면 조금 더 유연하게 스키마를 놓을 수 있음. 대신 애플리케이션에서 유연한 스키마에 대한 처리가 필요함.
> 2. 관계형 데이터베이스는 scale up으로 부족한 성능 문제를 해결하려는 경향이 강한 시스템임. 관계형 데이터베이스에 데이터가 굉장히 커지게 되고
> 하루에 쌓이는 데이터가 엄청나다면 데이터베이스 scale out 형태로 내부 데이터를 영역 별로 쪼갤 필요가 있음. 
> 그래야지 성능을 올리는 것 대비 가격을 줄이고 Throughput이 늘어나기 때문임. 
> 그걸 샤딩이라 하는데 문제는 관계형 데이터베이스로는 샤딩했을 때 처리가 굉장히 복잡해짐. 그리고 한번 샤딩 기준을 잡으면 나중에 바꾸기가 쉽지 않음.
> 비관계형 데이터베이스 DynamoDB, CockRoachDB 등은 이런 문제를 해결하려고 만들어진 DB임.
> 3. 빠른 속도를 위해서 사용이 되는 경우도 있음. Redis 같은 경우에는 인-메모리 기반으로 동작하기 떄문에 상대적으로 빠르게 처리할 수 있어서
> 캐시 용도로 사용해서 DB에 쏠리는 부하를 줄일 수 있음.