1. 서브 쿼리의 종류와 각각의 서브쿼리는 어떤 절에 사용할 수 있는지 설명해주세요.

> 문진수
>
> 서브쿼리에는 Nested Subquery, Inline View, Scalar Subquery가 있습니다. Nested Subquery의 경우 WHERE절에서 사용하는 서브 쿼리로 =, IN, ANY등 결과를 다양하게 사용할 수 있습니다. Inline View의 경우 FROM 절의 서브 쿼리로 임시적으로 테이블을 생성하여 해당 테이블로부터 조회를 수행합니다. Scalar Subquery의 경우 SELECT 절에서 사용되며 반드시 단 하나의 레코드만 결과로 나와야 합니다.

> 백명규
> 
> 서브쿼리의 종류에는 SELECT 절에 적용할 수 있는 nested subquery, FROM 절에 적용할 수 있는 inline view 그리고 WHERE 절에 적용할 수 있는 scala subquery 가 있습니다.
> 
> ※ (네이스~)

---
2. Full Table Scan과 Index range Scan의 차이는 무엇인가요? 상황 별 스캔이 유리한 경우에 관해서 말씀해주세요.

> 문진수
>
> Full Table Scan의 경우 테이블의 모든 레코드를 가져오는 것을 말합니다. 하나의 페이지에 모든 데이터가 들어있거나 조회되는 레코드의 개수가 너무 많은 경우 (25%정도 이상), 그리고 적절히 사용할 인덱스가 없는 경우 Full Table Scan이 실행 계획으로 잡힙니다. InnoDB는 Read-ahead 기능을 제공하는데 Full Table Scan을 할 때 점진적으로 백그라운드 스레드가 페이지를 계속 버퍼 풀에 적재합니다. 포그라운드 스레드는 버퍼 풀에서 데이터만 읽어서 응답해주게 됩니다. Index Range Scan은 인덱스를 사용할 수 있을 때 실행계획으로 잡히게 되고 인덱스 선두 컬럼이 반드시 조건절에 존재해야 합니다. 그리고 Secondary Index의 경우 리프 노드에 PK를 가지는데 이 순서는 해당 인덱스를 기준으로 정렬되기 때문에 레코드를 가져올 때는 각각의 데이터 조회마다 DIsk Random I/O가 발생하게 됩니다. 때문에 너무 많은 레코드를 조회하게 되면 Index를 사용하지 않고 Full Table Scan으로 실행 계획이 잡힙니다.

> 백명규
> 
> Full Table Scan은 테이블 내의 모든 데이터를 확인한 뒤 목적한 쿼리에서의 작업을 진행하고 Index range Scan은 인덱스를 활용하여 데이터 검색의 범위를 좁힌 뒤 필요한 부분의 데이터를 연속적으로 확인하여 목적한 쿼리에서의 작업을 진행합니다.
> 
> 어쩔 수 없이 모든 데이터에 대해서 변경이 필요한 경우 예를 들면 2025년 모든 회원의 나이를 증가 시켜야 하는 경우에는 Full Table Scan이 유리합니다. 
> 반면, 데이터의 범위를 최대한 좁혀 특정 회원의 정보를 가져와야한다거나 하는 경우와 같이 아주 적은 양의 데이터를 가져와야 하는 경우에는 index range scan을 통해 필요한 데이터에만 순차적으로 연속적으로 접근함으로써 디스크 접근을 최소화하는 방법이 유리합니다.

---
3. 커버링 인덱스에 대해서 설명해주세요.

> 문진수
>
> 쿼리에 필요한 모든 데이터가 인덱스에 포함되어 인덱스만으로 필요 사항을 만족시킬 수 있을 때 해당 인덱스를 커버링 인덱스라고 합니다. 커버링 인덱스로 처리될 경우 데이터에 접근하기 위한 추가적인 디스크 I/O가 발생하지 않기 때문에 속도가 빠릅니다.

---
4. Like 절로 조회를 해오려고 합니다. 이 때, Like 절로 조회한 데이터가 인덱스를 타지 못하는 경우에 대해서 설명해주세요.

> 문진수
>
> B Tree는 인덱스 왼쪽 컬럼을 기준으로 뒤의 값이 정렬됩니다. 때문에 %string과 같이 왼쪽 값으로 결정할 수 없는 경우에는 인덱스를 사용할 수 없습니다.

---