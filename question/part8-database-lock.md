1. 비관적 락과 낙관적 락에 관해서 설명해주세요.

> 문진수
>
> 비관적 락의 경우 SELECT FOR UPDATE로 DB 레코드에 다이렉트로 Lock을 잡는 방식입니다. Lock을 시도하는 TX가 많아지면 그만큼 지연이 발생하고 성능상 저하가 발생할 수 있습니다. 낙관적 락은 Versioning 방식으로 동작하며 Update 시점과 조회 시점의 버전 값을 비교하여 같으면 수정하고 다르면 재시도하는 방식입니다. 충돌이 많이 발생하면 재시도를 하게 되기 때문에 충돌 가능성이 적을 때 쓰면 좋습니다.

> 백명규
> 
> 비관적 락은 충돌이 발생할 것이라고 가정을 하고 데이터 조회를 할 때 명시적으로 트랜잭션을 여는 과정에서 자신이 조회하는 것에 대해 다른 세션에서 해당 데이터에 접근하여 추가적인 처리를 하는 것을 방지하는 역할을 합니다.
> 낙관적 락은 충돌이 발생할 가능성이 없다고 생각을 하고 조회를 진행한 다음 처리를 합니다. 
> 이 때, 처음 데이터를 조회했을 때의 해당 데이터의 버전 번호와 이후의 버전 번호가 다른 경우 다른 세션에서 데이터를 변경했으니 해당 세션에서 일어난 변경 요청에 대해서 모두 롤백해버립니다.
> 
> ※ 참고로 비관적 락의 경우에는 다른 락과 비교를 해보면 락을 잡고 세션이 대기해야 돼서 데이터베이스에 추가적인 부하를 줌.
> 선착순 같이 하나의 데이터에 여러 클라이언트가 접근하는 경우엔 서버에는 커넥션 부족으로 문제가 생길 수도 있음.
> 또한, 타임아웃을 세션 별로 잡아야 되기 때문에 애플리케이션 단에서 설정하기가 쉽지 않음.

---
2. 네임드 락에 관해서 설명해주세요.

> 문진수
>
> 네임드락은 DB 메타데이터에 락을 잡는 방식입니다. 기본적으로 락을 잡는 TX와 로직을 실행하는 TX가 분리되어야 하기 떄문에 커넥션을 2개 잡아먹습니다. 네임드 락을 많이 사용하면 커넥션 고갈이 발생할 수 있습니다.

> 백명규
> 
> 네임드 락은 특정한 테이블, 특정한 레코드에 대해서 잡는 락이 아니라 단순한 임의의 문자열에 대해서 선점하면 해당 문자열에 대한 점유를 막는 역할을 하며 MySQL에서 제공하는 기능입니다. 
> 사용을 할 때 주의할 점은 애플리케이션 레벨에서 해당 락을 사용하는 경우 커넥션을 두 개를 사용해야 한다는 점, 강제 종료됐을 때 특정 락에 관해서 반납을 하지 않는 문제를 조심해서 사용해야 합니다.
> 
> ※ 추가적인 자원이 필요하지 않고 분산락을 크게 사용하지 않을 것 같은 경우에 활용 가능

---
3. 분산 락에 관해서 설명해주세요.

> 문진수
>
> 분산락이란 다수의 서버가 동시에 동일한 자원에 접근하려 할 때 발생할 수 있는 동시성 문제를 해결하기 위한 동기화 메커니즘입니다. Redis를 이용한 분산락에서 자주 사용되는 SETNX 명령어는 해당 키가 존재하지 않을 때만 값을 설정합니다. 즉 키가 없으면 값을 세팅하고 1을 반환하며 이미 존재하면 아무 작업도 하지 않고 0을 반환합니다. Redis는 싱글 스레드 기반으로 동작하기 때문에 이러한 명령어들은 원자적으로 실행됩니다. 따라서 동시에 여러 클라이언트가 같은 락을 요청하더라도 한 번에 하나의 요청만 성공하고 나머지는 실패하게 되어 락의 동시 접근 문제가 없습니다.

> 백명규
> 
> 분산 락은 특정한 락에 대해서 특정 DBMS에서 제공하는 락이 아닙니다. 
> 일반적으로 자바에서의 자료 구조에 대해서는 synchronize로 설정을 하면 멀티스레드로 접근하는 데이터를 막을 수 있습니다. 
> 하지만 DBMS도 여러 서버에서 커넥션을 가지고 멀티스레드로 동작하여 DBMS의 데이터에 접근하고 데이터 변경을 할 수 있습니다. 
> 이 과정에서 일어날 수 있는 특정한 레코드 값에 대해서 동시성을 제어하기 위해 도입하는 것이 분산락이고 보통은 MySQL의 네임드락 혹은 Redis의 특정 자료구조를 사용해 key 값을 설정하여 해당 문자열 혹은 key 값에 대한 락을 획득하는 형태로 동작합니다.
> 
> ※ Redis에서는 set nx 기반으로 동작을 해서 특정한 락에 대해서 획득을 했냐 획득하지 못했냐를 기준으로 동작을 하는 분산 락 설정이 가능함.
> 공식 문서상의 redis 분산락 파트를 보면 redLock을 권장하는 이유에 관해서 적혀 있음.
> 
> 해당 개념에 관해서 정확하게 말하면 락에 대한 고가용성을 리플리케이션이나 그런 걸로 보장하는 게 아니라 단일 노드 레디스 N개(2k + 1)로 보장해주자라는 개념임.
> 그런데 어지간히 규모가 크지 않은 이상 이렇게 락 자체를 위해서 쓸 일은 없음. Redis 비싼데... 그냥 곁다리로 다른 기능이랑 짬뽕해서 쓰겠지.

---
4. Java의 애플리케이션 레벨에서 Synchronized 방식으로 동시성 제어를 하면 어떤 장단점이 있을까요?

> 문진수
>
> 간단하게 블록을 통해 적용이 가능하다는 장점이 있습니다. 하지만 락을 획득하지 못한 스레드는 WAITING 상태가 아닌 BLOCKED 상태로 바뀌기 때문에 상황에 따라 무기한 대기를 하게 될 수도 있습니다. 그리고 타임아웃 설정도 불가능합니다. 좀 더 세밀한 제어가 필요하거나 공정성이 필요하다면 ReentrantLock을 사용하는게 더 좋습니다. 그리고 인스턴스 수준의 락이기 때문에 다중 WAS 환경에서는 제대로 동작하지 않을 수 있습니다.

---
5. 데이터베이스에서의 공유 락과 베타 락에 관해서 설명해주세요. 동시에 여러 세션이 공유 락 혹은 베타 락을 잡는 것이 가능한가요?

> 문진수
>
> 공유락은 여러 세션이 동시에 획득이 가능합니다. 반면 배타락은 다른 세션의 공유락이나 배타락과 동시에 존재할 수 없습니다.